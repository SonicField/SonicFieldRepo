{
    ?signal Length !length
    Semitone       !step
    [(>step,0.50)** !step]
       80          !bands
       "C3" Note   !pitch
    bunch          !m-channels
    1.250          !enhance-channels
    0.0001         !gate
    1 Silence !output-signal 
    (>signal,2)DirectRelength !s-in
    (
        1,?bands,
        {
            ("Scanning channel ",?pitch)Println
            (?pitch,2)/  !p-use
            (?length,2)/ !l-use
            (?pitch,8)*  !p-use-l
            (?length,8)* !l-use-l
            {
                (?s-in,  ?p-use,0.1,18)RBJPeaking dbs-18 WaveLimit !signal
                (?signal,?p-use,0.1,18)RBJPeaking dbs-18 WaveLimit !signal
                (?signal,?p-use,0.1,18)RBJPeaking dbs-18 WaveLimit !signal
                [(?signal,?p-use,0.1,18)RBJPeaking dbs-18 WaveLimit !signal]
                (?signal,?p-use,0.1,18)RBJPeaking dbs-18 WaveLimit !chan-sig
                (?p-use period,2)/                          !pa
                (?p-use period,2)*                          !pr
                (?chan-sig,?pa,?pr)Follow WaveLimit         !chansig
                (>chan-sig,(?p-use,2)/,4)ButterworthLowPass !chan-sig
                [ Now enhance it ]
                (>chan-sig,?enhance-channels)Power !chan-sig
                [ Now gate it]
                (
                    (
                        (?chan-sig,?gate)Gate,
                        50,
                        4
                    )ButterworthLowPass,
                    >chan-sig
                )Multiply
            }Do !chan-sig
                        
            (?chan-sig,(1,16)/)DirectRelength !chan-sig
            (>p-use,2)/ !p-use
            {    
                ("Regenerating channel ",?pitch)Println
                (
                    (?p-use,440)Lt,
                    {
                        (
                            (?l-use-l,(?p-use,2)/)SinWave               pcnt+25,
                            (?l-use-l,(?p-use,4)/)SinWave               pcnt+25,
                            (?l-use-l,?p-use)SinWave                    pcnt+50
                        )Mix !wave
                    },
                    {
                        [ Should add brightness to the louder bits ]
                        (
                            (?l-use-l,(?p-use,2)*)SinWave               pcnt+25,
                            (?l-use-l,?p-use)SinWave                    pcnt+75
                        )Mix !wave
                    }
                )Choose Invoke
                >wave
            }Do !wave

            (
                >wave,
                ?chan-sig
            )Multiply !signal
                         
            (
                >signal,
                ,
                (
                    (>chan-sig dbs+1,2)Power,
                    (?l-use-l,(?p-use,8)*)SinWave
                )Multiply
            )Mix  RemoveDc !signal 
            
            (
                >signal,
                >output-signal
            )Mix RemoveDc !output-signal
            (>pitch,?step)* !pitch
        }
    )Repeat
    >output-signal
}!vocode

{
    (?signal,2000,8)BesselLowPass  !l
    (>signal,2000,8)BesselHighPass !h
    (>h Reverse,0.001)MaxDeviation Reverse !h 
    (>h,>l)Mix !signal Normalise
[
    (>signal,5000,1)ButterworthLowPass !signal
    (>signal,10000,6)ButterworthLowPass Normalise
]
}!pre-filter

{
    Bunch !out
    (
        (>signal,1500,1500)Granulate,
        {
            ^grain ^time
            (?time,(Random,100)*)+      !time
            ((>grain,>time),>out)AddEnd !out
        }
    )InvokeAll
    >out MixAt Normalise
}!haas-inner
{
    {(?signal,440,8)BesselLowPass  !signal ?haas-inner Do}Do !sl
    {(?signal,440,8)BesselHighPass !signal ?haas-inner Do}Do !sh
    (>sl,>sh)Mix Normalise 
}!haas

{     
    (
        {(?signal Normalise,50,50)Follow},
        {(?signal Normalise Reverse,50,50)Follow Reverse}
    )DoAll Mix !shape
    
    (?shape,(1,?shape MaxValue)/)NumericVolume !shape
    (>shape,2)Power                       !shape
    (0.001,>shape)DirectMix               !shape
    (
        ?signal,
        >shape 
    )Divide !signal
         
}!envelope-compress

{
    ("Compressing: ",?lower,"<",?upper)Println
    (?signal ,?lower, 4)BesselHighPass !signal
    (?signal ,?upper, 4)BesselLowPass  !signal
    ?envelope-compress Invoke
    (?signal ,?lower, 4)BesselHighPass !signal
    (?signal ,?upper, 4)BesselLowPass  !signal
}!compress-widen

{

    (
        (?signal Length WhiteNoise,500,6)ButterworthLowPass,
        0.0025
    )DirectResample Normalise !multi
    (
        >signal,
        (1,>multi dbs-6)DirectMix
    )Multiply Normalise
}!waver

{
    
    (   
        (?signal,10000,1)BesselHighPass,
        >signal
    )Mix Normalise !signal

    (
        (
            -0.03,0.2,0,-1,0.2,2,
            ?signal
        )WaveShaper pcnt+75,
        >signal pcnt+25
    )Mix Normalise !signal
    
    Bunch !sigs
    (
      1,14,
      {
        !band
        (?band,2)**           !bandl 
        ((>band,1)+,2)**      !bandh 
        ((?bandl,100)*,75)-   !lower
        ((?bandh,100)*,75)-   !upper
        ?compress-widen Do    !job
        (>job,>sigs)AddEnd    !sigs
      }
    )Repeat

    (
        >sigs Mix Normalise
        >signal
    )Mix !signal
    ?signal Length !len
    
    [Spatialize]
    ?haas Do !signal 
    
}!do-it 


[ A very desnse reflector
  Which splits the reflected wave form into smaller chunkcs
  reflects them and then recombines the results. This is
  very parallel.
]
{
    {
        >sample Normalise                    !sample
        (?sample,1000,5)BesselLowPass        !sampleL
        (?sample,3000,2)BesselLowPass        !sampleN
        (?sample,1000,4)ButterworthHighPass  !sampleH
        (>sampleH ,5000,2)BesselLowPass      !sampleH
        (?sample,((?first ,?offset)+ Prime Silence,(?sample,-13)Volume)Concatenate)Mix
        (
            1,2,
            {
                !z
                "." Print
                (>first,1.05)* Prime !first
                (>wet ,(((?first,30)-,?offset)- Silence,(?sampleL ,(-10,?z)-)Volume)Concatenate)Mix    !wet
                (>wet ,(((?first,30)+,?offset)- Silence,(?sampleN ,(-6, ?z)-)Volume)Concatenate)Mix    !wet
                (>wet ,((?first      ,?offset)- Silence,(?sampleH ,(-10,?z)-)Volume)Concatenate)Mix    !wet
            }
        )Repeat
        (?sampleL ,1000,1)BesselLowPass  !sampleL
        (?sampleN ,1000,1)BesselLowPass  !sampleN
        (?sampleH ,2000,1)BesselLowPass  !sampleH
        (
            (0,0),
            ((?wet  Length,3)/,1),
            (?wet   Length,0)
        )NumericShape !env
        (
            3,20,
            {
                !z
                (?z,4)/ !z
                (>first,1.1)* Prime !first
                (>wet ,(((?first,30)-,?offset)- Silence,((?sampleL ,(-7,?z)-)Volume,?env)Multiply)Concatenate)Mix  !wet
                (>wet ,(((?first,30)+,?offset)- Silence,((?sampleN ,(-4,?z)-)Volume,?env)Multiply)Concatenate)Mix  !wet
                (>wet ,((?first      ,?offset)- Silence,((?sampleH ,(-7,?z)-)Volume,?env)Multiply)Concatenate)Mix  !wet
            }
        )Repeat
        0.99 !l
        (
            20,80,
            {
                !z
                "." Print
                (?z,6)/ !z
                (>first,1.05)* Prime !first
                (>wet ,(((?first,30)-,?offset)- Silence,(((?sampleL ,(-7,?z)-)Volume,?env)Multiply,1000,2)BesselLowPass)Concatenate)Mix  !wet
                (>wet ,(((?first,30)+,?offset)- Silence,(((?sampleN ,(-4,?z)-)Volume,?env)Multiply, 500,2)BesselLowPass)Concatenate)Mix  !wet
                (>wet ,((?first      ,?offset)- Silence,(((?sampleH ,(-7,?z)-)Volume,?env)Multiply, 330,2)BesselLowPass)Concatenate)Mix  !wet
            }
        )Repeat
        (
            >wet    Normalise,
            >sample Invert
        )Mix
    } !reflector
    
    ?sample !dry
    bunch !dos
    (
        (>sample,?reflect-length)Granulate,
        {
            ^signal ^time
            "" Println
            ("Reverb at: ",?time)Println
            (?signal,>signal Length Silence)Concatenate !sample
            ?reflector Do !sample
            ((>sample,?time),>dos)AddEnd  !dos
        }
    )InvokeAll
    bunch !results
    (
        >dos,
        {
            ^signal ^time
            ((>signal Done,?time),>results)AddEnd  !results
        }
    )InvokeAll

    >results MixAt !signal
    
    [ Make it waver ]
    ?waver Do !wet
    [ Make it very wet ]
    (
        >wet,
        >dry Invert
    )Mix Normalise !wet
        
}!do-reflector

48000 SetSampleRate

"temp/input.wav" ReadFile Mix Normalise !signal
1 SetSwapLimit

?pre-filter Do Done !signal 
?vocode     Do Done !signal

((>signal Normalise),"temp/done-mono.wav")WriteFile32



"temp/done-mono.wav" ReadFile Mix Normalise !left !right
[
4 SetSwapLimit
>left  !signal
?do-it Do !left
>right !signal
?do-it Do !right


("Reverb")Println
  80 !first
  30 !offset
5000 !reflect-length
?left  !sample
?do-reflector Do !left-r
?right !sample
?do-reflector Do !right-r

{(>left pcnt+1,>left-r pcnt+99)Mix Normalise}Do !left
{(>right pcnt+1,>right-r pcnt+99)Mix Normalise}Do !right


((>left,>right)StereoMonitor,"temp/done.wav")WriteFile32
]
