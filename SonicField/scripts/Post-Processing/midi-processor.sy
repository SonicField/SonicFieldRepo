path="scripts/Post-Processing"
execfile(path+"/midi.sy")

sequence=Midi.readMidiFile("temp/well2.mid")

print 'Sequence Time  Type:', Midi.timeType(sequence)
print 'Sequence Resolution:', sequence.getResolution()
print 'Initial tick length:',Midi.tickLength(4,500000,sequence)
otl=Midi.tickLength(4,500000,sequence)

offset=20000
midiNo=1

midis=Midi.processSequence(sequence)    

for midi in midis:
    for event in midi:
        if Midi.isNote(event):
            ev1=event['event']
            ev2=event['event-off']
            ev1.setTick(ev1.getTick()+offset)
            ev2.setTick(ev2.getTick()+offset)

minKey=999
maxKey=0

for event in midis[midiNo]:
    if Midi.isNote(event):
        ev1=event['event']
        ev2=event['event-off']
        if event['key']>maxKey:
            maxKey=event['key']
        if event['key']<minKey:
            minKey=event['key']

# Fixed polyphony
# Round robbin through a fixed number of voices
# controlled by the 'voices' value.
def playVoices(voices=4):
    for voice in range(0,voices):
    
        sout=Midi.blankSequence(sequence)
        
        # Create the timing information track
        tout=sout.createTrack()
        for event in midis[0]:
            if Midi.isMeta(event):
                if Midi.isTempo(event) or Midi.isTimeSignature(event):
                    tout.add(event['event'])
        
        tout1=sout.createTrack()    
        midi1=[]
        
        rota =0
        for event in midis[midiNo]:
            if Midi.isNote(event):
                ev1=event['event']
                ev2=event['event-off']
                key=event['key']
                pan=127.0*float(key-minKey)/float(maxKey-minKey)
                pan=31+pan/2
                pan=int(pan)
                pan=Midi.makePan(1,ev1.getTick()-1,pan)
                if rota % voices== voice:
                    midi1.append(pan)
                    midi1.append(event['event'])
                    midi1.append(event['event-off'])
                rota+=1
        
        Midi.addPan(tout1,1,100,64)
        Midi.addNote(tout1,1,offset/2,10010,50,100)
        midi1=sorted(midi1,key=lambda event: event.getTick())
        
        for event in midi1:
            Midi.setChannel(event,1)
            tout1.add(event)
        
        Midi.writeMidiFile("temp/temp.midi",sout)
        
        for dev in Midi.getMidiDeviceNames():
            print dev
        
        player=Midi.getPlayer(3,2)
        player.play(sout)
        player.waitFor()

# Full polyphony
# Release sets the minimum time between notes on a
# particular voice unless those notes are the same
# key, which alows for the sound to go through its
# release phase. Voices sets the absoulte maximum
# number of voices which will be used before falling
# back to round robbin. 12 is a popular 'as big as you 
# need' value for polyphonic synths so I have picked
# that as the default. Release is in ticks.
#
# At the moment it is not clever enough to take account
# of tempo change events
def playNotes(release=120,voices=12):
    chans=[]
    for v in range(0,voices):
        chans.append([])
    
    voice=0
    for event in midis[midiNo]:
        if Midi.isNote(event):       
            for v in range(0,voices+1):
                v=v%voices
                chan=chans[v]
                if chan:
                    if chan[-1]['key']==event['key']:
                        break
                    top=chan[-1]['tick-off']
                    top+=release
                    if top<event['tick']:
                        break
                else:
                    break
            print v
            chans[v].append(event)
 
    for chan in chans:
        print chan
        
    sout=Midi.blankSequence(sequence)

    # Create the timing information track
    tout=sout.createTrack()
    for event in midis[0]:
        if Midi.isMeta(event):
            if Midi.isTempo(event) or Midi.isTimeSignature(event):
                tout.add(event['event'])

    nChan=0
    for chan in chans:
        if chan:
            nChan+=1
            tout=sout.createTrack();
            Midi.addPan(tout,1,100,64)
            Midi.addNote(tout,1,offset/2,10010,50,100)
            events=[]
            for event in chan:
                ev1=event['event']
                ev2=event['event-off']
                key=event['key']
                pan=127.0*float(key-minKey)/float(maxKey-minKey)
                pan=31+pan/2
                pan=int(pan)
                pan=Midi.makePan(1,ev1.getTick()-1,pan)
                events.append(pan)
                events.append(event['event'])
                events.append(event['event-off'])

            events=sorted(events,key=lambda event: event.getTick())
            
            for event in events:
                Midi.setChannel(event,1)
                tout.add(event)
    
    Midi.writeMidiFile("temp/temp.midi",sout)
    
    for dev in Midi.getMidiDeviceNames():
        print dev
    
    player=Midi.getPlayer(3,2)
    for trackNo in range(1,nChan):
        print "Playing track: ",trackNo
        player.playSolo(sout,0,trackNo)
        player.waitFor()

playNotes()  
  