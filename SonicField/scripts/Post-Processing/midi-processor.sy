path="scripts/Post-Processing"
execfile(path+"/midi.sy")


print "MIDI Devices:"        
for dev in Midi.getMidiDeviceNames():
    print dev

sequence=Midi.readMidiFile("temp/well2.mid")

print 'Sequence Time  Type:', Midi.timeType(sequence)
print 'Sequence Resolution:', sequence.getResolution()
print 'Initial tick length:',Midi.tickLength(4,500000,sequence)
otl=Midi.tickLength(4,500000,sequence)

offset=20000
dilate=1.0
midiNo=1
cut   =10

midis=Midi.processSequence(sequence)    

for midi in midis:
    for event in midi:
        if Midi.isNote(event):
            ev1=event['event']
            ev2=event['event-off']
            ev1.setTick(int(ev1.getTick()*dilate)+offset)
            ev2.setTick(int(ev2.getTick()*dilate)+offset)
        else:
            ev1=event['event']
            ev1.setTick(int(ev1.getTick()*dilate)+offset)

minKey=999
maxKey=0

for event in midis[midiNo]:
    if Midi.isNote(event):
        ev1=event['event']
        ev2=event['event-off']
        if event['key']>maxKey:
            maxKey=event['key']
        if event['key']<minKey:
            minKey=event['key']

# Fixed polyphony
# Round robbin through a fixed number of voices
# controlled by the 'voices' value.
def playVoices(voices=4):
    for voice in range(0,voices):
    
        sout=Midi.blankSequence(sequence)
        
        # Create the timing information track
        tout=sout.createTrack()
        for event in midis[0]:
            if Midi.isMeta(event):
                if Midi.isTempo(event) or Midi.isTimeSignature(event):
                    tout.add(event['event'])
        
        tout1=sout.createTrack()    
        midi1=[]
        
        rota =0
        for event in midis[midiNo]:
            if Midi.isNote(event):
                ev1=event['event']
                ev2=event['event-off']
                key=event['key']
                pan=127.0*float(key-minKey)/float(maxKey-minKey)
                pan=31+pan/2
                pan=int(pan)
                pan=Midi.makePan(1,ev1.getTick()-1,pan)
                if rota % voices== voice:
                    midi1.append(pan)
                    midi1.append(event['event'])
                    midi1.append(event['event-off'])
                rota+=1
        
        Midi.addPan(tout1,1,100,64)
        Midi.addNote(tout1,1,offset/2,offset/2+2000,50,100)
        midi1=sorted(midi1,key=lambda event: event.getTick())
        
        for event in midi1:
            Midi.setChannel(event,1)
            tout1.add(event)
        
        Midi.writeMidiFile("temp/temp.midi",sout)
        
        player=Midi.getPlayer(3,2)
        player.play(sout)
        player.waitFor()

# Full polyphony
# Release sets the minimum time between notes on a
# particular voice unless those notes are the same
# key, which alows for the sound to go through its
# release phase. Voices sets the absoulte maximum
# number of voices which will be used before falling
# back to round robbin. 12 is a popular 'as big as you 
# need' value for polyphonic synths so I have picked
# that as the default. Release is in ticks.
#
# At the moment it is not clever enough to take account
# of tempo change events
def playNotes(release=120,sameRelease=60,voices=12):
    chans=[]
    for v in range(0,voices):
        chans.append([])
    
    voice=0
    vs=[]
    rota=0
    for event in midis[midiNo]:
        if Midi.isNote(event):
            notFound=True
            for v in range(0,2*(voices+1)):
                second=v>voices                
                v+=rota
                v=v%voices
                chan=chans[v]
                if chan:
                    top=chan[-1]['tick-off']
                    next=event['tick']
                    if chan[-1]['key']==event['key']:
                        if top+sameRelease<next:
                            notFound=False
                            rota+=1                        
                            break
                    if top+release<next and second:
                        rota+=1
                        notFound=False
                        break
                else:
                    notFound=False
                    break

            if notFound:
                v=rota
                v=v%voices
                rota+=1
            vs.append(v)
            chans[v].append(event)
    print "Voicing:",vs
 
    for chan in chans:
        print chan    

    sout=Midi.blankSequence(sequence)  
    # Create the timing information track
    tout=sout.createTrack()
    for event in midis[0]:
        if Midi.isMeta(event):
            if Midi.isTempo(event) or Midi.isTimeSignature(event):
                tout.add(event['event'])
    for chan in chans:
        if chan:

            events=[]
            for event in chan:
                ev1=event['event']
                ev2=event['event-off']
                key=event['key']
                pan=127.0*float(key-minKey)/float(maxKey-minKey)
                pan=31+pan/2
                pan=int(pan)
                pan=Midi.makePan(1,ev1.getTick()-1,pan)
                events.append(pan)
                events.append(event['event'])
                events.append(event['event-off'])

            events=sorted(events,key=lambda event: event.getTick())

            # Create note track
            tout=sout.createTrack()
            Midi.addPan(tout,1,100,64)
            Midi.addNote(tout,1,offset/2,(offset/2)+20,50,100)

            for event in events:
                Midi.setChannel(event,1)
                tout.add(event)
    Midi.writeMidiFile("temp/temp.midi",sout)
 

    nChan=0
    for chan in chans:
        if chan:
            nChan+=1
            print "Performing Channel: :",chan
            events=[]
            for event in chan:
                ev1=event['event']
                ev2=event['event-off']
                key=event['key']
                pan=127.0*float(key-minKey)/float(maxKey-minKey)
                pan=31+pan/2
                pan=int(pan)
                pan=Midi.makePan(1,ev1.getTick()-1,pan)
                events.append(pan)
                events.append(event['event'])
                events.append(event['event-off'])

            events=sorted(events,key=lambda event: event.getTick())
                    
            sout=Midi.blankSequence(sequence)  
 
            # Create the timing information track
            tout=sout.createTrack()
            for event in midis[0]:
                if Midi.isMeta(event):
                    if Midi.isTempo(event) or Midi.isTimeSignature(event):
                        tout.add(event['event'])

            # Create note track
            tout=sout.createTrack()
            Midi.addPan(tout,1,100,64)
            Midi.addNote(tout,1,offset/2,(offset/2)+20,50,100)

            for event in events:
                Midi.setChannel(event,1)
                tout.add(event)
            player=Midi.getPlayer(3,2)
            #player=Midi.getPlayer(1,0)
            player.play(sout)
            player.waitFor()
    

#playVoices(2)  
playNotes(release=120,sameRelease=60,voices=10)