import math
import random
import sys

def granularReverb(signal,ratio,delay,density,length=50,stretch=1,vol=1):
    out=[]
    for grain in sf.Granulate(signal,length,10):
        (signal_i,at)=grain
        signal_i=sf.Realise(signal_i)
        signal_i=sf.DirectRelength(signal_i,ratio)
        for x in range(0,density):
            out.append(
                (
                    +signal_i,
                    int((at + (random.random()+random.random())*delay)*stretch)
                )
            )
        -signal_i
  
    out=sf.Collapse(out)
    out=sf.Realise(sf.FixSize(sf.MixAt(out)))
    out=sf.Clean(sf.NumericVolume(out,vol))
    return out

def reverbInner(signal,convol,grainLength):
    mag=sf.Magnitude(+signal)
    if mag>0:
        signal_=sf.Concatenate(signal,sf.Silence(grainLength))
        signal_=sf.FrequencyDomain(signal_)
        signal_=sf.CrossMultiply(convol,signal_)
        signal_=sf.TimeDomain(signal_)
        newMag=sf.Magnitude(+signal_)
        signal_=sf.NumericVolume(signal_,mag/newMag)        
        # tail out clicks due to amplitude at end of signal 
        return signal_
    else:
        -convol
        -signal
        return sf.Silence(0)

def reverberate(signal,convol):
    def reverbI():
        grainLength = sf.Length(+convol)
        convol_=sf.FrequencyDomain(sf.Concatenate(convol,sf.Silence(grainLength)))
        signal_=sf.Concatenate(signal,sf.Silence(grainLength))
        out=[]
        for grain in sf.Granulate(signal_,grainLength):
            (signal_i,at)=grain
            inp=reverbInner(signal_i,+convol_,grainLength)
            if sf.Length(+inp)>0:
                out.append((inp,at))
            else:
                -inp
        -convol_
        return sf.Clean(sf.FixSize(sf.MixAt(out)))
    return sf_do(reverbI)

def bombardPulse(length,frequency):
    p=random.random()
    if frequency>4000:
        sig=sf.Mix(
            sf.PhasedSineWave(length,frequency,p),
            sf.NumericVolume(sf.PhasedSineWave(length,frequency*2.0,p),2.0),
            sf.NumericVolume(sf.PhasedSineWave(length,frequency*3.0,p),1.5),
            sf.NumericVolume(sf.PhasedSineWave(length,frequency*4.0,p),1.3),
            sf.NumericVolume(sf.PhasedSineWave(length,frequency*5.0,p),1.2),
            sf.NumericVolume(sf.PhasedSineWave(length,frequency*6.0,p),1.0),
            sf.NumericVolume(sf.PhasedSineWave(length,frequency*7.0,p),0.8),
            sf.NumericVolume(sf.PhasedSineWave(length,frequency*8.0,p),0.5)
            )
    else:
        sig=sf.Mix(
            sf.PhasedSineWave(length,frequency,p),
            sf.NumericVolume(sf.PhasedSineWave(length,frequency*2.0,p),2.0),
            sf.NumericVolume(sf.PhasedSineWave(length,frequency*3.0,p),1.5),
            sf.NumericVolume(sf.PhasedSineWave(length,frequency*4.0,p),1.3),
            sf.NumericVolume(sf.PhasedSineWave(length,frequency*5.0,p),1.2),
            sf.NumericVolume(sf.PhasedSineWave(length,frequency*6.0,p),1.0),
            sf.NumericVolume(sf.PhasedSineWave(length,frequency*7.0,p),0.8),
            sf.NumericVolume(sf.PhasedSineWave(length,frequency*8.0,p),0.6),
            sf.NumericVolume(sf.PhasedSineWave(length,frequency*9.0,p),0.4),
            sf.NumericVolume(sf.PhasedSineWave(length,frequency*10.0,p),0.2)
        )
    return sf.FixSize(sig)

def ophicleidePulse(length,frequency):
    p=random.random()
    if frequency>4000:
        sig=sf.Mix(
            sf.PhasedSineWave(length,frequency,p),
            sf.NumericVolume(sf.PhasedSineWave(length,frequency*2.0,p),1.5),
            sf.NumericVolume(sf.PhasedSineWave(length,frequency*3.0,p),2.0),
            sf.NumericVolume(sf.PhasedSineWave(length,frequency*4.0,p),2.0),
            sf.NumericVolume(sf.PhasedSineWave(length,frequency*5.0,p),1.5),
            sf.NumericVolume(sf.PhasedSineWave(length,frequency*6.0,p),1.0),
            sf.NumericVolume(sf.PhasedSineWave(length,frequency*7.0,p),0.8),
            sf.NumericVolume(sf.PhasedSineWave(length,frequency*8.0,p),0.5)
            )
    elif frequency>1000:
        sig=sf.Mix(
            sf.PhasedSineWave(length,frequency,p),
            sf.NumericVolume(sf.PhasedSineWave(length,frequency*2.0,p),1.5),
            sf.NumericVolume(sf.PhasedSineWave(length,frequency*3.0,p),2.0),
            sf.NumericVolume(sf.PhasedSineWave(length,frequency*4.0,p),2.0),
            sf.NumericVolume(sf.PhasedSineWave(length,frequency*5.0,p),1.5),
            sf.NumericVolume(sf.PhasedSineWave(length,frequency*6.0,p),1.0),
            sf.NumericVolume(sf.PhasedSineWave(length,frequency*7.0,p),0.9),
            sf.NumericVolume(sf.PhasedSineWave(length,frequency*8.0,p),0.8),
            sf.NumericVolume(sf.PhasedSineWave(length,frequency*9.0,p),0.6),
            sf.NumericVolume(sf.PhasedSineWave(length,frequency*10.0,p),0.4)
        )
    else:
        sig=sf.Mix(
            sf.PhasedSineWave(length,frequency,p),
            sf.NumericVolume(sf.PhasedSineWave(length,frequency*2.0,p),1.5),
            sf.NumericVolume(sf.PhasedSineWave(length,frequency*3.0,p),2.0),
            sf.NumericVolume(sf.PhasedSineWave(length,frequency*4.0,p),2.0),
            sf.NumericVolume(sf.PhasedSineWave(length,frequency*5.0,p),1.8),
            sf.NumericVolume(sf.PhasedSineWave(length,frequency*6.0,p),1.6),
            sf.NumericVolume(sf.PhasedSineWave(length,frequency*7.0,p),1.4),
            sf.NumericVolume(sf.PhasedSineWave(length,frequency*8.0,p),1.2),
            sf.NumericVolume(sf.PhasedSineWave(length,frequency*9.0,p),1.0),
            sf.NumericVolume(sf.PhasedSineWave(length,frequency*10.0,p),0.8),
            sf.NumericVolume(sf.PhasedSineWave(length,frequency*11.0,p),0.5),
            sf.NumericVolume(sf.PhasedSineWave(length,frequency*12.0,p),0.3),
            sf.NumericVolume(sf.PhasedSineWave(length,frequency*13.0,p),0.2),
            sf.NumericVolume(sf.PhasedSineWave(length,frequency*14.0,p),0.1)
       )   
    return sf.FixSize(sig)
    
def nicePulse(length,frequency):
    p=random.random()
    if frequency>4000:
        sig=sf.Mix(
            sf.PhasedSineWave(length,frequency,p),
            sf.NumericVolume(sf.PhasedSineWave(length,frequency*2.0,p),1.0/1.5),
            sf.NumericVolume(sf.PhasedSineWave(length,frequency*3.0,p),1.0/1.0),
            sf.NumericVolume(sf.PhasedSineWave(length,frequency*4.0,p),1.0/1.0),
            sf.NumericVolume(sf.PhasedSineWave(length,frequency*5.0,p),1.0/1.5),
            sf.NumericVolume(sf.PhasedSineWave(length,frequency*6.0,p),1.0/2.0),
            sf.NumericVolume(sf.PhasedSineWave(length,frequency*7.0,p),1.0/3.0),
            sf.NumericVolume(sf.PhasedSineWave(length,frequency*8.0,p),1.0/4.0)
            )
    else:
        sig=sf.Mix(
            sf.PhasedSineWave(length,frequency,p),
            sf.NumericVolume(sf.PhasedSineWave(length,frequency*2.0,p),1.0/1.5),
            sf.NumericVolume(sf.PhasedSineWave(length,frequency*3.0,p),1.0/1.0),
            sf.NumericVolume(sf.PhasedSineWave(length,frequency*4.0,p),1.0/1.0),
            sf.NumericVolume(sf.PhasedSineWave(length,frequency*5.0,p),1.0/1.5),
            sf.NumericVolume(sf.PhasedSineWave(length,frequency*6.0,p),1.0/2.0),
            sf.NumericVolume(sf.PhasedSineWave(length,frequency*7.0,p),1.0/3.0),
            sf.NumericVolume(sf.PhasedSineWave(length,frequency*8.0,p),1.0/4.0),
            sf.NumericVolume(sf.PhasedSineWave(length,frequency*9.0,p),1.0/6.0),
            sf.NumericVolume(sf.PhasedSineWave(length,frequency*10.0,p),1.0/10.0)
        )
    return sf.FixSize(sig)

def makeSimpleBase(length,frequency,z):
    p=random.random()
    if frequency>4000:
        sig=sf.Mix(
            sf.PhasedSineWave(length,frequency,p),
            sf.NumericVolume(sf.PhasedSineWave(length,frequency*2.0,p),(1.0/2.0)**z),
            sf.NumericVolume(sf.PhasedSineWave(length,frequency*3.0,p),(1.0/3.0)**z),
            sf.NumericVolume(sf.PhasedSineWave(length,frequency*4.0,p),(1.0/4.0)**z),
            sf.NumericVolume(sf.PhasedSineWave(length,frequency*5.0,p),(1.0/5.0)**z),
            sf.NumericVolume(sf.PhasedSineWave(length,frequency*6.0,p),(1.0/6.0)**z),
            sf.NumericVolume(sf.PhasedSineWave(length,frequency*7.0,p),(1.0/7.0)**z),
            sf.NumericVolume(sf.PhasedSineWave(length,frequency*8.0,p),(1.0/8.0)**z)
            )
    else:
        sig=sf.Mix(
            sf.PhasedSineWave(length,frequency,p),
            sf.NumericVolume(sf.PhasedSineWave(length,frequency*2.0,p),(1.0/2.0)**z),
            sf.NumericVolume(sf.PhasedSineWave(length,frequency*3.0,p),(1.0/3.0)**z),
            sf.NumericVolume(sf.PhasedSineWave(length,frequency*4.0,p),(1.0/4.0)**z),
            sf.NumericVolume(sf.PhasedSineWave(length,frequency*5.0,p),(1.0/5.0)**z),
            sf.NumericVolume(sf.PhasedSineWave(length,frequency*6.0,p),(1.0/6.0)**z),
            sf.NumericVolume(sf.PhasedSineWave(length,frequency*7.0,p),(1.0/7.0)**z),
            sf.NumericVolume(sf.PhasedSineWave(length,frequency*8.0,p),(1.0/8.0)**z),
            sf.NumericVolume(sf.PhasedSineWave(length,frequency*9.0,p),(1.0/9.0)**z),
            sf.NumericVolume(sf.PhasedSineWave(length,frequency*10.0,p),(1.0/10.0)**z)
        )
    return sf.FixSize(sig)

def niceSaw(length,frequency):
    return makeSimpleBase(length,frequency,1.0)

def violaBase(length,frequency):
    return makeSimpleBase(length,frequency,0.5)

def sweetFluteBase(length,frequency):
    return makeSimpleBase(length,frequency,8.0)
    
def brightFluteBase(length,frequency):
    return makeSimpleBase(length,frequency,3.5)

def stoppedPulse(length,frequency):
    p=random.random()
    if frequency>3000:
        sig=sf.Mix(
            sf.PhasedSineWave(length,frequency,p),
            sf.NumericVolume(sf.PhasedSineWave(length,frequency*3.0,p),1.0/1.0),
            sf.NumericVolume(sf.PhasedSineWave(length,frequency*5.0,p),1.0/1.5),
            sf.NumericVolume(sf.PhasedSineWave(length,frequency*7.0,p),1.0/2.0)
            )
    else:
        sig=sf.Mix(
            sf.PhasedSineWave(length,frequency,p),
            sf.NumericVolume(sf.PhasedSineWave(length,frequency*3.0,p),1.0/1.0),
            sf.NumericVolume(sf.PhasedSineWave(length,frequency*5.0,p),1.0/1.5),
            sf.NumericVolume(sf.PhasedSineWave(length,frequency*7.0,p),1.0/2.0),
            sf.NumericVolume(sf.PhasedSineWave(length,frequency*9.0,p),1.0/4.0),
            sf.NumericVolume(sf.PhasedSineWave(length,frequency*11.0,p),1.0/8.0)
        )
    return sf.FixSize(sig)


def cleanNoise(length,freq):
    return sf.FixSize(
        sf.FixSize(
            sf.BesselLowPass(
                sf.ButterworthHighPass(
                    sf.Clean(sf.WhiteNoise(length)),
                    freq*0.25,
                    4
                ),
                2000,
                1
            )       
        )
    )

def pitchMove(sig):
    l=sf.Length(+sig)
    if l>1024:
        move=sf.NumericShape(
            (0,0.995+random.random()*0.01),
            (l,0.995+random.random()*0.01)
        )
    elif l>512:
        move=sf.NumericShape(
            (0,0.9975+random.random()*0.005),
            (l,0.9975+random.random()*0.005)
        )
    else:
        return sig
    return sf.Clean(sf.Resample(move,sig))
    
def polish(sig,freq):
    if freq > 64:
        sig=sf.ButterworthHighPass(sig,freq*0.66,6)
    else:
        sig=sf.ButterworthHighPass(sig,freq*0.66,2)   
    return sf.Clean(sig)

###############################################################################
#
# Voices
#
###############################################################################

def celestFlute(length,freq):
    sig=sf.Mix(
        sf.Pcnt50(sweetFluteBase(length,freq)),
        sf.Pcnt50(sweetFluteBase(length,freq+1.0)),
        sf.Multiply(
            cleanNoise(length,freq*0.5),
            sf.SimpleShape((0,-60),(64,-28),(128,-40),(length,-40))
        )
    )
    return pitchMove(sig)

def sweetFlute(length,freq):
    sig=sf.Mix(
        sweetFluteBase(length,freq),
        sf.Multiply(
            cleanNoise(length,freq*0.5),
            sf.SimpleShape((0,-60),(64,-30),(128,-40),(length,-40))
        )
    )
    sig=sf.FixSize(polish(sig,freq))
    return pitchMove(sig)

def brightFlute(length,freq):
    sig=sf.Mix(
        brightFluteBase(length,freq),
        sf.Multiply(
            cleanNoise(length,freq*0.5),
            sf.SimpleShape((0,-60),(64,-28),(128,-40),(length,-40))
        )
    )
    sig=sf.FixSize(polish(sig,freq))
    return pitchMove(sig)

def string(length,freq):
    def ms():
        sig=sf.Mix(
            sf.Pcnt45(sf.MakeTriangle(sf.PhasedSineWave(length,freq,random.random()))),
            sf.Pcnt25(sf.MakeTriangle(sf.PhasedSineWave(length,freq*2.0,random.random()))),
            sf.Pcnt15(sf.MakeTriangle(sf.PhasedSineWave(length,freq*4.0,random.random()))),
            sf.Pcnt15(sf.PhasedSineWave(length,freq*6.0,random.random())),
            sf.Multiply(
                cleanNoise(length,freq),
                sf.SimpleShape((0,-60),(64,-20),(128,-36),(length,-36))
            )
        )
        sig=polish(sig,freq)
        sig=sf.FixSize(polish(sf.Saturate(sig),freq))
        return pitchMove(sig)
        
    return sf.FixSize(sf.Mix(ms(),ms()))

def viola(length,freq):
    sig=sf.Mix(
        roundedStringBase(length,freq),
        sf.Multiply(
            cleanNoise(length,freq*0.5),
            sf.SimpleShape((0,-60),(64,-20),(128,-36),(length,-36))
        )
    )
    sig=sf.FixSize(polish(sig,freq))
    return pitchMove(sig)

def leadDiapason(length,freq):
    sig=sf.Mix(
        sf.Pcnt65(sf.MakeTriangle(sf.PhasedSineWave(length,freq,random.random()))),
        sf.Pcnt25(sf.MakeTriangle(sf.PhasedSineWave(length,freq*2.0,random.random()))),
        sf.Pcnt15(sf.PhasedSineWave(length,freq*4.0,random.random())),
        sf.Multiply(
            cleanNoise(length,freq),
            sf.SimpleShape((0,-60),(64,-20),(128,-36),(length,-36))
        )
    )
    sig=sf.FixSize(polish(sig,freq))
    return pitchMove(sig)

def secondDiapason(length,freq):
    sig=sf.Mix(
        sf.MakeTriangle(sf.PhasedSineWave(length,freq,random.random())),
        sf.Pcnt25(sf.MakeTriangle(sf.PhasedSineWave(length,freq*2.0,random.random()))),
        sf.Pcnt15(sf.PhasedSineWave(length,freq*4.0,random.random())),
        sf.Pcnt5(sf.PhasedSineWave(length,freq*8.0,random.random())),
        sf.Multiply(
            cleanNoise(length,freq),
            sf.SimpleShape((0,-60),(64,-20),(128,-26),(length,-20))
        )
    )
    sig=sf.FixSize(polish(sig,freq))
    return pitchMove(sig)

def grandBass(length,freq):
    sig=sf.Mix(
        sf.MixAt(
            [sf.Pcnt25(niceSaw(length,freq)),0],
            [sf.Pcnt50(sf.MakeTriangle(sf.PhasedSineWave(length,freq*0.501,random.random()))),32],
            [sf.Pcnt25(sf.MakeTriangle(sf.PhasedSineWave(length,freq*0.252,random.random()))),64],
            [sf.Pcnt25(sf.MakeTriangle(sf.PhasedSineWave(length,freq/8.01,random.random()))),64]
        ),          
        sf.Multiply(
            cleanNoise(length,freq),
            sf.SimpleShape((0,-60),(64,-12),(128,-24),(length,-20))
        )
    )
    sig=sf.BesselLowPass(sig,freq*3.0,1)
    sig=sf.FixSize(polish(sig,freq))
    return pitchMove(sig)

def doubleBombard(length,freq):
    sig=sf.Mix(
        sf.MixAt(
            [sf.Pcnt33(bombardPulse(length,freq/1.5)),20],
            [sf.Pcnt33(bombardPulse(length,freq)),0],
            [sf.Pcnt33(bombardPulse(length,freq*1.5)),10],
        ),          
        sf.Multiply(
            cleanNoise(length,freq*0.5),
            sf.SimpleShape((0,-60),(64,-16),(128,-24),(length,-20))
        )
    )
    return pitchMove(sig)

def bombard(length,freq):
    b=sf.MixAt(
            [sf.Pcnt33(bombardPulse(length,freq)),0],
            [sf.Pcnt33(bombardPulse(length,freq)),10],
            [sf.Pcnt33(bombardPulse(length,freq)),20]
    )
    b=polish(b,freq)
    sig=sf.Mix(
        b
        ,
        sf.Pcnt10(sf.Multiply(+b,sf.WhiteNoise(length))),          
        sf.Multiply(
            cleanNoise(length,freq*0.5),
            sf.SimpleShape((0,-60),(64,-20),(128,-28),(length,-24))
        )
    )
    return pitchMove(sig)

def singleBombard(length,freq):
    sig=sf.Mix(
        sf.Pcnt33(bombardPulse(length,freq))
        ,          
        sf.Multiply(
            cleanNoise(length,freq*0.5),
            sf.SimpleShape((0,-60),(64,-16),(128,-24),(length,-20))
        )
    )
    return pitchMove(sig)

def ophicleide(length,freq):
    b=sf.MixAt(
            [sf.Pcnt10(ophicleidePulse(length,freq*0.25-1)),0],
            [sf.Pcnt20(ophicleidePulse(length,freq)),15],
            [sf.Pcnt20(ophicleidePulse(length,freq)),10],
            [sf.Pcnt20(ophicleidePulse(length,freq*2.0)),5],
            [sf.Pcnt20(ophicleidePulse(length,freq*3.0)),0]
    )
    b=sf.Mix(
        sf.Power(+b,2.0),
        sf.Pcnt10(sf.Raise(+b,2.0)),
        sf.Pcnt50(b)
    )
    b=polish(b,freq)
    sig=sf.Mix(
        sf.Pcnt90(b)
        ,
        sf.Pcnt10(sf.FixSize(sf.Multiply(+b,cleanNoise(length,freq*2.0)))),          
        sf.Multiply(
            cleanNoise(length,freq*0.5),
            sf.SimpleShape((0,-60),(64,-16),(128,-20),(length,-22))
        )
    )
    return sig


def upperAccent(length,freq):
    return sf.FixSize(
        polish(
            sf.Power(
                polish(
                    sf.MakeTriangle(
                        sf.SineWave(length,freq)
                    ),
                    freq
                )
               ,2.0
            ),
            freq
        )
    )

def clarion(length,freq):
    s1=sf.MakeTriangle(sf.PhasedSineWave(length,freq,random.random()))
    s2=sf.MakeTriangle(sf.PhasedSineWave(length,freq*2.001,random.random()))
    s3=niceSaw(length,freq*4.002)
    s1=polish(s1,freq)
    s2=polish(s2,freq)
    s3=polish(s3,freq)
    
    sig=sf.Mix(
        sf.Pcnt70(s1),
        sf.Pcnt20(s2),
        sf.Pcnt10(s3),
        sf.Multiply(
            cleanNoise(length,freq*2.0),
            sf.SimpleShape((0,-60),(64,-20),(128,-36),(length,-36))
        )
    )

    sig=sf.FixSize(sf.Power(sig,10.0))
    sig=polish(sig,freq)
    sig=sf.BesselLowPass(sig,freq*6.0,2)
    return sf.FixSize(sf.Clean(sig))
    
def warmBass(length,freq):
    sig=sf.Mix(
        sf.FixSize(
            sf.Power(
                sf.Clean(
                    sf.MixAt(
                        [sf.Pcnt25(sf.MakeSquare  (sf.PhasedSineWave(length,freq      ,random.random()))),0],
                        [sf.Pcnt50(sf.MakeTriangle(sf.PhasedSineWave(length,freq*0.501,random.random()))),32],
                        [sf.Pcnt25(sf.MakeTriangle(sf.PhasedSineWave(length,freq*0.252,random.random()))),64],
                        [sf.Pcnt25(sf.MakeTriangle(sf.PhasedSineWave(length,freq/8.01,random.random()))),64]
                    )
                )
                ,1.25
            )
        ),      
        sf.Multiply(
            cleanNoise(length,freq),
            sf.SimpleShape((0,-60),(64,-12),(128,-24),(length,-24))
        )
    )
    sh=sf.WhiteNoise(length)
    sh=sf.Multiply(sh,+sig)
    sig=sf.Mix(sig,sf.Pcnt5(sh))

    if freq<128:
        q=freq*6.0
    elif freq<256:
        q=freq*5
    else:
        q=freq*4.0
    sig=sf.BesselLowPass(sig,q,1)
    return pitchMove(sig)


def simpleOboe(length,freq):
    sig=sf.FixSize(
        sf.Power(
            sf.Clean(
                sf.Mix(
                    niceSaw(length,freq),
                    sf.PhasedSineWave(length,freq,random.random())
                )
            )
            ,
            1.5
        )
    )
    sig=polish(sig,freq)
    sig=sf.FixSize(sf.Power(sig,1.5))
    sig=polish(sig,freq)
    sig=sf.FixSize(sf.Power(sig,1.5))
    sig=polish(sig,freq)
    sig=sf.FixSize(sig)
      
    sig=sf.RBJPeaking(sig,freq*5,0.5,5)
    sig=sf.RBJPeaking(sig,freq*7,1,5)
    sig=sf.RBJNotch  (sig,freq*2,0.5,1)
    sig=sf.Clean(sig)
    
    sig=sf.Mix(
        sf.FixSize(sig),
        sf.Multiply(
            cleanNoise(length,freq*9.0),
            sf.SimpleShape((0,-60),(64,-20),(128,-24),(length,-24))
        )
    )

    sig=sf.ButterworthLowPass (sig,freq*9,4)
    sig=polish(sig,freq)
    return sf.FixSize(sig)

def muteOboe(length,freq):
    sig=sf.FixSize(
        sf.Power(
            sf.Clean(
                sf.Mix(
                    niceSaw(length,freq),
                    sf.PhasedSineWave(length,freq,random.random())
                )
            )
            ,
            1.5
        )
    )
    sig=polish(sig,freq)
    sig=sf.FixSize(sf.Power(sig,1.5))
    sig=polish(sig,freq)
    sig=sf.FixSize(sf.Power(sig,1.5))
    sig=polish(sig,freq)
    sig=sf.FixSize(sig)      

    sig=sf.RBJPeaking(sig,freq*5,0.5,5)
    sig=sf.RBJPeaking(sig,freq*7,1,5)
    sig=sf.RBJNotch  (sig,freq*2,0.5,1)
    sig=sf.Clean(sig)
    
    sig=sf.Mix(
        sf.FixSize(sig),
        sf.Multiply(
            cleanNoise(length,freq*9.0),
            sf.SimpleShape((0,-60),(64,-16),(128,-20),(length,-20))
        )
    )

    sig=polish(sig,freq)
    sig=sf.BesselLowPass (sig,freq*4,1)
    osig=+sig
    osig=sf.BesselHighPass(sig,freq*4,2)
    sig=sf.BesselLowPass (sig,freq*6,1)
    sig=sf.BesselLowPass (sig,freq*8,4)
    sig=sf.Mix(sig,osig)
    return sf.FixSize(sf.Clean(sig))

def richReed(length,freq):
    s1=bombardPulse(length,freq*1.000)
    s2=nicePulse(length,freq+1)
    s3=nicePulse(length,freq-1.5)
    s1=polish(s1,freq)
    s2=polish(s2,freq)
    s3=polish(s3,freq)
    
    sig=sf.Mix(
        sf.Pcnt70(s1),
        sf.Pcnt20(s2),
        sf.Pcnt10(s3),
        sf.Multiply(
            cleanNoise(length,freq*2.0),
            sf.SimpleShape((0,-60),(64,-20),(128,-24),(length,-24))
        )
    )

    sig=sf.FixSize(sig)
    sig=polish(sig,freq)
    return sf.FixSize(sig)

def reed(length,freq):
    s1=nicePulse(length,freq*1.000)
    s1=polish(s1,freq)
    
    sig=sf.Mix(
        s1,
        sf.Multiply(
            cleanNoise(length,freq*2.0),
            sf.SimpleShape((0,-60),(64,-16),(128,-20),(length,-20))
        )
    )

    sig=sf.FixSize(sig)
    sig=polish(sig,freq)
    return sf.FixSize(sig)

def stoppedReed(length,freq):
    s1=stoppedPulse(length,freq*1.000)
    sig=polish(s1,freq)
    
    sig=sf.Mix(
        s1,
        sf.Multiply(
            cleanNoise(length,freq*2.0),
            sf.SimpleShape((0,-60),(64,-16),(128,-20),(length,-20))
        )
    )

    sig=sf.FixSize(sig)
    sig=sf.Mix(
        sf.Pcnt10(sf.Clean(sf.Saturate(+sig))),
        sig
    )
    sig=polish(sig,freq)
    return sf.FixSize(sig)

###############################################################################
# END VOICES
###############################################################################

def safeEnv(sig,env):
    length=sf.Length(+sig)
    ne=[]
    op=0
    for p,m in env:
        if p-op<16 and p>0:
            print "Warning: envelope to tight: ", env
            p=op+16
        op=p
        ne.append([p,m])
    if p>length:
        raise "envelop failure"
    return sf.NumericShape(ne)
         
def sing(hint,pitch,lengthIn,beat,v,vl,vr,voice,vCorrect_,qFactor,subBass,flatEnv):
    def singInner():
        vCorrect=vCorrect_
        length=lengthIn
        tp=0
        
        # minimum play time
        if length<192:
            length=192
            tp=0  
        elif length<363:
            length+=128
            tp=1
        elif length<512:
            length+=256
            tp=2
        elif length<1024:
            length+=128
            tp=3
        else:
            tp=4
    
        sig=[]
        if pitch<330:
            x=5
        elif pitch<880:
            x=6
        else:
            x=3
        for x in range(0,x):
            vc=voice(length,pitch*(1.0+random.random()*0.005))
            vc=sf.Multiply(
                safeEnv(
                    vc,
                    [
                        (0,0),
                        (24,1),
                        (sf.Length(+vc)-24,1),
                        (sf.Length(+vc),0)
                    ]
                ),
                vc
            )
            sig.append(
                sf.NumericVolume(
                    sf.Concatenate(
                        sf.Silence(24*random.random()),
                        vc
                    )
                    ,random.random()+0.25
                )
             )
        sig=sf.Realise(sf.Mix(sig))
        
        sig = sf.FixSize(sig)
        length=sf.Length(+sig)
        
        pHint=hint[0]
        nHint=hint[1]
        shine=False
        if tp==0:
            if pHint=="T":
                q=32
            else:
                q=64
            if nHint=="T":
                p=32
            else:
                p=64
            q*=qFactor
            env=safeEnv(sig,[(0,0),(q,1),(192-p,0.5),(length,0)])
            if hint=="TT":
                vCorrect*=0.8
            elif hint=="NN" and pitch>660:
                shine=True
                vCorrect*=0.5        
        elif tp==1 or flatEnv:
            if pHint=="T":
                q=48
            else:
                q=96
            if nHint=="T":
                p=64
            else:
                p=128
            q*=qFactor
            env=safeEnv(sig,[(0,0),(q,0.75),(length-p,1.0),(length,0)])
            if hint=="TT":
                vCorrect*=0.8            
            if hint=="TT":
                vCorrect*=0.8
            elif hint=="NN" and pitch>880:
                shine=True
                vCorrect*=0.6
        elif tp==2:
            env=safeEnv(sig,[(0,0),(96*qFactor,0.75),(length-256,1.0),(length,0)])
        elif tp==3:
            if length<1280:
                env=safeEnv(sig,[(0,0),(64*qFactor,0.5),(256,1),(512,0.75),((length-512)/2.0+512,0.5),(length,0)])
            else:
                env=safeEnv(sig,[(0,0),(64*qFactor,0.5),(256,1),(512,0.75),(length-512,0.75),(length,0)])
        else:
            env=safeEnv(sig,[(0,0),(64*qFactor,0.25),(512,1),(length/2,0.75),(length,0)])

        mod=sf.NumericShape((0,0.995),(length,1.005))
        mod=sf.Mix(mod,sf.NumericVolume(+env,0.01))
        sig=sf.FrequencyModulate(sig,mod)  
        sig=sf.FixSize(sig)
     
        if pitch<256:
            if subBass:
                if pitch < 128:
                    sig=sf.Mix(
                        granularReverb(+sig,ratio=0.501 ,delay=256,density=32,length=256,stretch=1,vol=0.20),
                        granularReverb(+sig,ratio=0.2495,delay=256,density=32,length=256,stretch=1,vol=0.10),
                        sig
                    )
                elif pitch < 192:
                    sig=sf.Mix(
                        granularReverb(+sig,ratio=0.501,delay=256,density=32,length=256,stretch=1,vol=0.25),
                        sig
                    )
                else:
                    sig=sf.Mix(
                        granularReverb(+sig,ratio=0.501,delay=256,density=32,length=256,stretch=1,vol=0.15),
                        sig
                    )
            sig=sf.BesselLowPass(sig,pitch*8.0,2)
        if pitch<392:
            sig=sf.BesselLowPass(sig,pitch*6.0,2)
        elif pitch<512:
            sig=sf.Mix(
                sf.BesselLowPass(+sig,pitch*6.0, 2),
                sf.BesselLowPass( sig,pitch*3.0, 2)
            )                
        elif pitch<640:
            sig=sf.BesselLowPass(sig,pitch*3.5, 2)
        elif pitch<1280:
            sig=sf.Mix(
                sf.BesselLowPass(+sig,pitch*3.5, 2),
                sf.BesselLowPass( sig,pitch*5.0, 2)
            )                
        else:
            sig=sf.Mix(
                sf.BesselLowPass(+sig,pitch*5, 2),
                sf.BesselLowPass( sig,5000,    1)
            )

        sig=sf.Multiply(sig,env)                     
        sig=sf.FixSize(sig)
        
        cnv=sf.WhiteNoise(10240)
        cnv=sf.ButterworthHighPass(cnv,32,4)
        if shine:
            q=640
            print "Shine"
        else:
            q=256
        cnv=sf.Cut(5000,5000+q,cnv)
        cnv=sf.Multiply(cnv,sf.NumericShape((0,0),(32,1),(q,0)))
        sigr=reverberate(+sig,cnv)
        sigr=sf.Multiply(
            safeEnv(sigr,[(0,0),(256,1),(sf.Length(+sigr),1.5)]),
            sigr
        )
        sig=sf.Mix(
            sf.Pcnt20(sigr),
            sf.Pcnt80(sig)
        )
        
        note=sf.NumericVolume(sf.FixSize(sig),v)
        sf.Check(note)
        notel=sf.Realise(sf.NumericVolume(+note,vl*vCorrect))
        noter=sf.Swap(sf.NumericVolume( note,vr*vCorrect))
        return (notel,noter)
    return sf_do(singInner)

def doMidi(count,notesStart,notesEnd,notes,midi,voice,vCorrect,pitchShift=1.0,qFactor=1.0,subBass=False,flatEnv=False):
    print "Stop: ",voice
    for index in range(0,len(midi)):
        if index>0:
            prev=midi[index-1]
        else:
            prev=()
        if index<len(midi)-1:
            next=midi[index+1]
        else:
            next=()
        current=midi[index]
        tickOn,tickOff,note,key,velocity = current
        if count>notesEnd:
            break
        at=tickOn*beat
        if count<notesStart:
            count+=1
            continue
        length=(tickOff-tickOn)*beat
        if key==0:
            pitch=base
        else:
            key=float(key)
            pitch= (sf.Semitone(0)**key) * base * pitchShift
        velocity=velocity/100
        v=velocity
        pl=pitch

        vCUse=vCorrect
        
        # volume pitch correction to stop domination
        # of high notes - not quite the same as 
        # loudness correction due to the high dominating
        # low perception issue.
        pCorrect=1
        if vCorrect>0.25 and pitch > 660 :
            if length <256:
                sCorrect=1.5
            else:
                sCorrect=1.0
            pCorrect=1.0
            if pitch>660:
                if pitch<2000:
                    pCorrect=float(2000-pitch)/1340.0
                    pCorrect=0.40*(1.0-pCorrect)+pCorrect
                elif pitch<4000:
                    pCorrect=float(8000-pitch)/4000.0
                    pCorrect=0.75*(1.0-pCorrect)+0.4*pCorrect
            pCorrect*=sCorrect
            if pCorrect>1:
                pCorrect=1
        vCUse*=pCorrect

        if pl<300:
            # low to the right ish
            if pl <100:
                pl=100
            pl=float(pl-100)/200.0
            pl=pl*0.5+0.4
            lr=pl
        elif pl <880:
            # middle across all
            pl=float(pl-300)/580.0
            pl=pl*0.8+0.1
            lr=pl
        else:
            # high off to the left
            pl=pl-880
            pl=float(pl-880)/880.0
            if pl>1:
                pl=1
            pl=0.05+pl*0.3
            lr=pl
        
        rl=1.0-lr
        
        # Compute hint
        # Two letters - first for previous note
        # second for next note
        # S=start
        # T=trill
        # N=normal
        # E=end
        hint=""
        if len(prev):
            to,tf,n,k,v=prev
            lp=(tf-to)*beat
            ep=tf*beat
            # quick close previous note
            if at-ep < 100 and lp<256:
                hint+="T"
            else:
                hint+="N"
        else:
            hint+="S"
        if len(next):
            to,tf,n,k,v=next
            sn=to*beat
            # quick close previous note
            if sn-at < 100+length and length<256:
                hint+="T"
            else:
                hint+="N"
        else:
            hint+="E"
 
        print "H",hint,"C",count,"P",pitch,"@",at,"L",length,"V",velocity,"VU",vCUse,"PC",pCorrect
        note = sing(hint,pitch, length,beat,v,lr,rl,voice,vCUse,qFactor,subBass,flatEnv)
        dl=30*rl+1000
        dr=38*lr+1000
        notes.append((note,at+dl,at+dr))
        count+=1

def unpackMidi(tup,beat):
            tickOn,tickOff,note,key,velocity = tup
            at  = tickOn*beat
            llen = (tickOff-tickOn)*beat
            if key==0:
                pitch=base
            else:
                pitch= (sf.Semitone(0)**float(key)) * base
            return tickOn,tickOff,note,key,velocity,at,llen,pitch

def interpretMidiBombast(midi,beat):
    change=True
    while change:
        change=False
        print "Interpretation Pass"
        endAt=len(midi)-1
        index=0
        midiOut=[]
        while index<endAt:
            this=midi[index]
            next=midi[index+1]
            ttickOn,ttickOff,tnote,tkey,tvelocity,tAt,tLen,tPitch = unpackMidi(this,beat)
            ntickOn,ntickOff,nnote,nkey,nvelocity,nAt,nLen,nPitch = unpackMidi(next,beat)
    
            # Merge interpretation
            finished=False
            if tLen>512:
                #print "Checking ",tPitch==nPitch, tvelocity==nvelocity,ntickOn-ttickOff,nLen>256,tPitch<256
                if tPitch==nPitch and tvelocity==nvelocity and (ntickOn-ttickOff)<128 and (ntickOn-ttickOff)>-16:
                    # go for a low pitch merge
                    # below middle C
                    if nLen>256 and tPitch<256:
                        finished=True
                        midiOut.append([ttickOn,ntickOff,tnote,tkey,tvelocity])
                        print "Merging: ",this," & ",next
                        index+=1
                        change=True
    
            if not finished:
                midiOut.append(this)
                if index==endAt-1:
                    midiOut.append(next)
                
            # iterate the loop
            index+=1
        midi=midiOut
    return midi

def interpretMidiStaccato(midi,beat):
    print "Interpretation Pass"
    endAt=len(midi)-1
    index=0
    midiOut=[]
    while index<endAt:
        this=midi[index]
        next=midi[index+1]
        ttickOn,ttickOff,tnote,tkey,tvelocity,tAt,tLen,tPitch = unpackMidi(this,beat)
        ntickOn,ntickOff,nnote,nkey,nvelocity,nAt,nLen,nPitch = unpackMidi(next,beat)

        # Merge interpretation
        finished=False
        if tLen>512:
            if (ntickOn-ttickOff)<128:
                ttickOff-=128
                midiOut.append([ttickOn,ntickOff,tnote,tkey,tvelocity])
                print "Staccato: ",this," & ",next
                finished=True
    
        if not finished:
            midiOut.append(this)
            if index==endAt-1:
                midiOut.append(next)
            
        # iterate the loop
        index+=1
    return midiOut

def my_so(what):
    return what()

########################
# Two manual stops
########################

# Soft two manual settings:
# =========================
# First manual  = leadDiapason  ,2.0
# Pedals manual = warmBass      ,1.5,subBass=True

# Grand two manual settings:
# ==========================
# First manual  = secondDiapason,2.0
# Pedals manual = warmBass      ,1.5,subBass=True
# Pedals manual = upperAccent   ,0.2,x4

# Standard two manual settings:
# =============================
# First manual  = leadDiapason  ,2.0
# Second manual = secondDiapason,0.8
# Second manual = upperAccent,0.1,x4

# Bright two manual settings:
# ===========================
# First manual  = leadDiapason  ,2.0
# Second manual = secondDiapason,0.8
# Second manual = upperAccent   ,0.1,x4
# Second manual = clarion       ,0.2,x2

# Warm two manual settings:
# ===========================
# First manual  = leadDiapason  ,2.0
# Second manual = secondDiapason,0.8
# Second manual = upperAccent   ,0.4,x2
# Second manual = warmBass      ,0.2,x0.5

# Oboe two manual settings:
# ===========================
# First manual  = simpleOboe    ,0.4
# First manual  = secondDiapson ,1.2
# Second manual = leadDiapason  ,1.0
# Second manual = upperAccent   ,0.4,x2
# Second manual = warmBass      ,0.2,x0.5

# Counterpoint 3 manual and pedals 
# With clarion on the second to give
# shining inverted lead
# ================================
# First manual  = leadDiapason   ,1.2
# Second manual = clarion        ,0.8
# Third manual  = secondDiapason ,1.2
# Third manual  = upperAccent    ,0.1,x2
# Pedals        = warmBass       ,1.5,subBass=True
# Padels        = upperAccent    ,0.2,x4

# Counterpoint 3 manual and pedals 
# With more traditional lead on
# first and accent. Accent pedals
# with an oboe to give baroque 
# feel. Fast attach on lead if you
# are playing very fast
# ================================
# First manual  = leadDiapason   ,1.5,0.5
# Second manual = secondDiapaon  ,0.8
# Second manual = upperAccent    ,0.1,x2
# Third manual  = secondDiapason ,0.8
# Third manual  = upperAccent    ,0.1,x2
# Pedals        = warmBass       ,1.5,subBass=True
# Padels        = simpleOboe     ,0.1,x2
# Padels        = simpleOboe     ,0.1,x4

# Baroque 3 manual and pedals 
# With clarion on the first to give
# shining lead and a grand bass 
# for a much more modern sound, but
# maybe too much?
# ================================
# First manual  = clarion        ,1.4,0.5
# First manual  = clarion        ,0.2,1.995,0.33
# Second manual = leadDiapason   ,0.8
# Second manual = upperAccent    ,0.2,x2
# Third manual  = leadDiapason   ,0.8
# Third manual  = upperAccent    ,0.2,x2
# Pedals        = grandBass      ,2.5
# Pedals        = warmBass       ,1.5,x0.501,subBass=True
# Padels        = upperAccent    ,0.2,x4
# Padels        = upperAccent    ,0.1,x8

# Counterpoint 3 manual and pedals 
# Clean sound warm bass
# ================================
# First manual  = leadDiapason   ,0.5
# First manual  = leadDiapason   ,0.5,1.001
# Second manual = secondDiapaon  ,0.8
# Third manual  = secondDiapason ,0.8
# Pedals        = warmBass       ,1.5,subBass=True
# Padels        = upperAccent    ,0.2,x4

# 3 oboes manuals and pedals 
# ================================
# First manual  = muteOboe       ,1.0,0.5
# Second manual = muteOboe       ,1.0,0.5
# Third manual  = muteOboe       ,1.0,0.5
# Pedals        = warmBass       ,1.5,subBass=True
# Padels        = upperAccent    ,0.1,x4

# 2 diapason manuals oboe instead 
# of pedals 
# ================================
# First manual  = secondDiapaon  ,1.0
# Second manual = secondDiapaon  ,1.0
# Third manual  = muteOboe       ,1.5

# Counterpoint 3 manual and pedals 
# Controlled brass
# ================================
# First manual  = clarion        ,0.6
# First manual  = leadDiapason   ,0.6,1.001
# Second manual = secondDiapaon  ,0.8
# Third manual  = secondDiapason ,0.8
# Pedals        = warmBass       ,1.5,subBass=True
# Padels        = upperAccent    ,0.2,x4

# 2 Inverted diapason and read 3
# manuals
# ================================
# First manual  = stoppedReed    ,1.0
# Second manual = stoppedReed    ,1.0
# Third manual  = leadDiapason   ,1.0
# Third manual  = grandBass      ,0.5,x0.5


# Counterpoint 3 manual and pedals 
# Bass Heavy - very complex
# ================================
# First manual  = clarion        ,0.4
# First manual  = leadDiapason   ,0.4,1.001
# Second manual = secondDiapaon  ,0.8
# Third manual  = secondDiapason ,0.8
# Third manual  = upperAccent    ,0.2,x4,subBass=False,qFactor=0.5
# Pedals        = warmBass       ,1.5,subBass=True
# Padels        = stoppedReed    ,0.501,x0.5,subBass=True
# Padels        = upperAccent    ,0.2,x4

# Bombasic 5 parts (2 pedals)
# ===========================
# First manual  = string         ,1.2
# First manual  = string         ,0.33,2.0
# Second manual = richRead       ,1.0
# Second manual = voice=upperAccent,vCorrect=0.25,pitchShift=2.0,qFactor=0.5,subBass=False
# Third manual  = muteOboe       ,1.0
# Third manual  = voice=upperAccent,vCorrect=0.25,pitchShift=2.0,qFactor=0.5,subBass=False
# Fourth Pedals = voice=bombard,vCorrect=1.0,subBass=False,flatEnv=True
# Fourth Padels = voice=ophicleide,pitchShift=0.5,vCorrect=0.5,subBass=False,flatEnv=True
# Fith Pedals   = voice=bombard,vCorrect=1.0,subBass=False,flatEnv=True
# Fourth Padels = voice=ophicleide,pitchShift=0.5,vCorrect=0.5,subBass=False,flatEnv=True

#######################################
# Timing configuration and running midi
#######################################

midis=sf.ReadMidiFile("temp/064500b_c.mid")
signature   =     4.0/4.0
bpm         =     380 * signature
adqf        =     1.0
beat        =     (60000.0 / (bpm * 192.0)) * adqf
base        =     8.1757989156
notesl=[]
notesr=[]
notes=[]
count       =     0.0
notesStart  =     0.00
notesEnd    =  9999.0

def postProcess():
    count=0
    for note in notes:
        nlr,atl,atr=note
        print "Done: ",count,atl,atr
        notel,noter=nlr
        notesl.append([notel,atl])
        notesr.append([noter,atr])
        count+=1

print "Channel 1A"
midi=midis[1]
doMidi(count,notesStart,notesEnd,notes,midi,sweetFlute,1.2)
postProcess()

notes=[]
count = 0.0
print "Channel 1B"
doMidi(count,notesStart,notesEnd,notes,midi,celestFlute,0.33,2.0)
postProcess()

notes=[]
count = 0.0
print "Channel 1+A"
midi=interpretMidiBombast(midis[2],beat)
doMidi(count,notesStart,notesEnd,notes,midi,string,vCorrect=0.5,pitchShift=2.0)
postProcess()

notes=[]
count = 0.0
print "Channel 1+B"
midi=interpretMidiBombast(midis[2],beat)
doMidi(count,notesStart,notesEnd,notes,midi,upperAccent,vCorrect=0.2,pitchShift=4.0)
postProcess()

notes=[]
count = 0.0
print "Channel 2A"
midi=interpretMidiStaccato(midis[3],beat)
doMidi(count,notesStart,notesEnd,notes,midi,brightFlute,1.0)
postProcess()

notes=[]
count = 0.0
print "Channel 2B"
doMidi(count,notesStart,notesEnd,notes,midi,voice=celestFlute,vCorrect=0.25,pitchShift=2.0,qFactor=0.5,subBass=False)
postProcess()

notes=[]
count = 0.0
print "Channel 3A"
midi=interpretMidiBombast(midis[4],beat)
doMidi(count,notesStart,notesEnd,notes,midi,brightFlute,1.0)
postProcess()

notes=[]
count = 0.0
print "Channel 3B"
doMidi(count,notesStart,notesEnd,notes,midi,voice=celestFlute,vCorrect=0.25,pitchShift=2.0,qFactor=0.5,subBass=False)
postProcess()

notes=[]
count = 0.0
print "Channel 4A"
midi=interpretMidiStaccato(midis[5],beat)

#count,notesStart,notesEnd,notes,midi,voice,vCorrect,pitchShift=1.0,qFactor=1.0
doMidi(count,notesStart,notesEnd,notes,midi,secondDiapason,vCorrect=1.0,subBass=False,flatEnv=True)
postProcess()

notes=[]
count = 0.0
print "Channel 4B"
doMidi(count,notesStart,notesEnd,notes,midi,secondDiapason,pitchShift=0.5,vCorrect=0.5,subBass=False,flatEnv=True)
postProcess()
    
notes=[]
count = 0.0
print "Channel 4C"
doMidi(count,notesStart,notesEnd,notes,midi,upperAccent,0.2,4.0)
postProcess()

notes=[]
count = 0.0
print "Channel 5A"
midi=interpretMidiStaccato(midis[6],beat)
doMidi(count,notesStart,notesEnd,notes,midi,secondDiapason,pitchShift=0.5,vCorrect=1.0,subBass=False,flatEnv=True)
postProcess()

notes=[]
count = 0.0
print "Channel 5B"
doMidi(count,notesStart,notesEnd,notes,midi,secondDiapason,pitchShift=0.5,vCorrect=0.5,subBass=False,flatEnv=True)
postProcess()

notes=[]
count = 0.0
print "Channel 5C"
doMidi(count,notesStart,notesEnd,notes,midi,upperAccent,0.2,4.0)
postProcess()

notes=[]
count = 0.0
print "Channel 6"
midi=interpretMidiStaccato(midis[7],beat)
doMidi(count,notesStart,notesEnd,notes,midi,bombard,0.5,0.5)
postProcess()

notes=[]
count = 0.0
print "Channel 7"
midi=interpretMidiBombast(midis[8],beat)
doMidi(count,notesStart,notesEnd,notes,midi,clarion,0.5,0.5)
postProcess()


def mix(notes):
    def mixInner():
        return sf.Realise(sf.FixSize(sf.Clean(sf.MixAt(notes))))
    return sf_do(mixInner)
print "Mix"
left =mix(notesl)
right=mix(notesr)

sf.WriteFile32((left,right),"temp/temp.wav")
